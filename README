ПРОБЛЕМА:

	После приблизительно пятисот успешных циклов создания потока для подключившегося
клиента и его завершения по окончании обработки запроса серверу не удается создавать
потоки более: вызывается исключение

	terminate called after throwing an instance of
	'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector
			<boost::thread_resource_error> >
	what():  boost thread: failed in pthread_create: Resource temporarily unavailable

При этом при текущих значениях констант сервером не может быть создано более 10
потоков одновременно, а пользователь, от имени которого запускаются сервер и клиент,
не имеет никаких ограничений на число процессов или дескрипторов.  	Работают сервер
и клиент по следующей схеме:

	Сервер хранит массив размером в number_of_clients (параметр конструктора класса
Server) счетчиков посещений различными клиентами и ожидает подлкючение в цикле
server/testServer.cpp:15@[void Server::start()]. При подключении клиента сервер
создает отдельный поток server/testServer.cpp:32@[void Server::clientThread(
		tcp::socket *client_socket_)] для него и ожидает от клиента его уникальный
id в диапазоне от 0 до number_of_clients - 1, терминированный символом
server/testServer.hpp:11@[int const kSeparator = '$']. Сервер считывает счетчик
посещений и отправляет клиенту его актуальное значение, затем немедленно закрывает
соединение. Далее сервер инкрементирует счетчик клиента и глобальный счетчик
server/testServer.hpp:43@[volatile int global_counter_], защищая последний мьютексом.
Клиент же сравнивает полученное от сервера значение с ожидаемым, в случае совпадения
пишет в консоль ok, иначе [FAIL]. Инкементирует свой счетчик.

	Тестирующая система client/main.cpp создает client/testClient.hpp:7@
		[int const kNumberOfClients = 10] клиентов в отдельных потоках, каждый из
которых последовательно осуществляет client/testClient.hpp:6@[int const
		kNumberOfConnectionsPerClient = 100] соединений с сервером, в каждом из
которых после успешного установления соединения выжидает client/testClient.hpp:10@
		[int const kPauseLength = 1000] миллисекунд, а затем отправляет свой id.
Дальнейшие события разворачиваются так, как было описано выше.

	Раз в server/testServer.hpp:14@[int const kUpdatePeriod = 20] успешных соединений
с клиентами сервер печатает в std::cout табличку с информацией о том, какой клиент
сколько раз был подключен к серверу. Так как остальной лог сервера выводится в
std::cerr удобно фильтровать этот вывод так:

	./server/testServer 2> log  

